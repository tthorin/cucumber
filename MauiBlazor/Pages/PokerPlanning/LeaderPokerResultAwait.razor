@using _SharedSignalR.Models;
@inject ISignalrContext signalR;
@implements IDisposable;

@*-----------------------------------------------------------------------------------------*@

<div class="leader-vote-wait-container">
	<div class="room-name">
		<p>Votes received @votes.Votes.Count / @numberOfClients</p>
		<p>Room: @signalR.Settings.Room</p>
	</div>
	<div class="vote-progress-container">
		<progress id="vote-progress" max="100" value="@votePercent">@votePercent %</progress>
	</div>
	<h1>Votes</h1>
	@if (votes.Votes.Count == 0)
	{
		<p>Waiting for votes...</p>
	}
	else
	{
		<table>
			<thead>
				<tr>
					<td>Name</td>
					<td>Vote</td>
				</tr>
			</thead>
			<tbody>
				@foreach (var vote in votes.Votes.OrderBy(x => x.Answer))
				{
					<tr>
						<td>@vote.Username</td>
						<td>@vote.Answer</td>
					</tr>
				}
			</tbody>
		</table>
	}
<button @onclick="()=>PokerNavChanged.InvokeAsync(Pages.LeaderPokerSelectStyle)" class="styled close-btn">Close Vote</button>
</div>


@*-----------------------------------------------------------------------------------------*@
@code {
	[Parameter]
	public Pages PokerNav { get; set; }
	[Parameter]
	public EventCallback<Pages> PokerNavChanged { get; set; }
	[CascadingParameter]
	public int numberOfClients { get; set; }

	private PokerVoteResults votes;
	private List<IDisposable> disposables = new();
	private int votePercent;

	protected override void OnInitialized()
	{
		votes = new() { Room = signalR.Settings.Room };
		disposables.AddRange(new[]
		{
			signalR.OnPokerVote(OnPokerVote)
	});
	}

	private async void OnPokerVote(PokerVote vote)
	{
		votes.Votes.Add(vote);

		await signalR.SendPokerVoteResult(votes);

		votePercent = votes.Votes.Count * 100 / numberOfClients;
		await InvokeAsync(StateHasChanged);
	}

	public void Dispose()
	{
		foreach (var item in disposables)
		{
			item.Dispose();
		}
	}
}